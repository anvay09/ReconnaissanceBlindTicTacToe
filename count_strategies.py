# -*- coding: utf-8 -*-
"""count strategies

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uesWj5uY2T1laV9IZXmDT_30St5wgvSA
"""

from tqdm import tqdm

#@title TicTacToe Board Functions

class TicTacToeBoard:
    def __init__(self, board = None):
        if board is None:
            self.board = create_board()
            # self.history = history
        else:
            self.board = board.copy()
            # self.history = history

    # def __str__(self):
    #     return self.board.decode(encoding = 'utf-8')

    # def __arr__(self):
    #     return convert_to_array(self.board)

    # def add_to_history(self, move):
    #     self.history += str(move)

    def make_move(self, move, turn):
        # self.board = convert_to_bytearray(make_move(self.__arr__(), move, turn))
        self.board = make_move(self.board, move, turn)
        # self.add_to_history(move)
        return self.board

    def is_win(self):
        # return is_win(self.__arr__())
        return is_win(self.board)

    def is_draw(self):
        # return is_draw(self.__arr__())
        return is_draw(self.board)

    def is_over(self):
        # return is_over(self.__arr__())
        return is_over(self.board)


    def copy(self):
        return TicTacToeBoard(self.board)

    def win_exists(self, turn):
        # return win_exists(self.__arr__(), turn)
        return win_exists(self.board, turn)

    def opponent_win_exists(self, turn):
        # return opponent_win_exists(self.__arr__(), turn)
        return opponent_win_exists(self.board, turn)

    def has_perfect_information(self):
        # return has_perfect_information(self.__arr__())
        return has_perfect_information(self.board)

    # overload [] operator
    def __getitem__(self, key):
        # return self.__arr__()[key]
        return self.board[key]

    # assign to [] operator
    def __setitem__(self, key, value):
        # arr = self.__arr__()
        self.board[key] = value
        # self.board = convert_to_bytearray(arr)


    def __eq__(self, other):
        return self.board == other.board

#---------------------------------------------#

# def convert_to_bytearray(board):
#     board_str = ''
#     for i in range(9):
#         board_str += board[i]

#     board_str = board_str.encode(encoding = 'utf-8')
#     return board_str

# def convert_to_array(board):
#     board_str = board.decode(encoding = 'utf-8')

#     board = []
#     for c in board_str:

#         board.append(c)

#     return board

def create_board():
    board = ['-'] * 9
    # board = bytearray('---------', encoding = 'utf-8')
    return board

def toggle_turn(turn):
    if turn == 'x':
        return 'o'
    elif turn == 'o':
        return 'x'

def print_board(board):
    # board = convert_to_array(board)
    print("+---+---+---+")
    for i in range(3):
        print("|", end="")
        for j in range(3):
            if board[3 * i + j] == 'x':
                print(" x ", end="|")
            elif board[3 * i + j] == 'o':
                print(" o ", end="|")
            elif board[3 * i + j] == '-':
                print(" - ", end="|")
            else:
                print(" 0 ", end="|")
        print("\n+---+---+---+")

def make_move(board, move, turn): # expects decoded board
    if ((board[move] != '-') and
        (board[move] != '0')):
        return None
    board[move] = turn

    return board

def is_win(board): # expects decoded board
    for i in range(3):
        if ((board[3 * i] == board[3 * i + 1] == board[3 * i + 2] != '0') and
            (board[3 * i] == board[3 * i + 1] == board[3 * i + 2] != '-')):
            return True, board[3 * i]

        if ((board[i] == board[i + 3] == board[i + 6] != '0') and
            (board[i] == board[i + 3] == board[i + 6] != '-')):
            return True, board[i]

    if ((board[0] == board[4] == board[8] != '0') and
        (board[0] == board[4] == board[8] != '-')):
        return True, board[0]

    if ((board[2] == board[4] == board[6] != '0') and
        (board[2] == board[4] == board[6] != '-')):
        return True, board[2]

    return False, None

def is_draw(board): # expects decoded board
    win, _ = is_win(board)

    if win:
        return False
    for i in range(9):
        if board[i] == '0':
            return False
        elif board[i] == '-':
            return False
    return True

def is_over(board): # expects decoded board
    for i in range(9):
        if board[i] == '0':
            return False
        elif board[i] == '-':
            return False
    return True

def copy(board): # expects decoded board
    new_board = board.copy()
    return new_board

def win_exists(board, turn): # expects decoded board
    if (board[0] == '0' and board[1] == turn and board[2] == turn):
        return True, 0
    elif (board[0] == turn and board[1] == '0' and board[2] == turn):
        return True, 1
    elif (board[0] == turn and board[1] == turn and board[2] == '0'):
        return True, 2
    elif (board[3] == '0' and board[4] == turn and board[5] == turn):
        return True, 3
    elif (board[3] == turn and board[4] == '0' and board[5] == turn):
        return True, 4
    elif (board[3] == turn and board[4] == turn and board[5] == '0'):
        return True, 5
    elif (board[6] == '0' and board[7] == turn and board[8] == turn):
        return True, 6
    elif (board[6] == turn and board[7] == '0' and board[8] == turn):
        return True, 7
    elif (board[6] == turn and board[7] == turn and board[8] == '0'):
        return True, 8
    elif (board[0] == '0' and board[3] == turn and board[6] == turn):
        return True, 0
    elif (board[0] == turn and board[3] == '0' and board[6] == turn):
        return True, 3
    elif (board[0] == turn and board[3] == turn and board[6] == '0'):
        return True, 6
    elif (board[1] == '0' and board[4] == turn and board[7] == turn):
        return True, 1
    elif (board[1] == turn and board[4] == '0' and board[7] == turn):
        return True, 4
    elif (board[1] == turn and board[4] == turn and board[7] == '0'):
        return True, 7
    elif (board[2] == '0' and board[5] == turn and board[8] == turn):
        return True, 2
    elif (board[2] == turn and board[5] == '0' and board[8] == turn):
        return True, 5
    elif (board[2] == turn and board[5] == turn and board[8] == '0'):
        return True, 8
    elif (board[0] == '0' and board[4] == turn and board[8] == turn):
        return True, 0
    elif (board[0] == turn and board[4] == '0' and board[8] == turn):
        return True, 4
    elif (board[0] == turn and board[4] == turn and board[8] == '0'):
        return True, 8
    elif (board[2] == '0' and board[4] == turn and board[6] == turn):
        return True, 0
    elif (board[2] == turn and board[4] == '0' and board[6] == turn):
        return True, 4
    elif (board[2] == turn and board[4] == turn and board[6] == '0'):
        return True, 6
    else:
        return False, -1

def get_true_board(player_board, other_player_board): # expects decoded board
    true_board = create_board()
    # true_board = convert_to_array(true_board)

    for square in range(9):
        if player_board[square] == other_player_board[square]:
            if player_board[square] == '0':
                true_board[square] = '-'
            else:
                true_board[square] = player_board[square]
        elif player_board[square] == 'x' or other_player_board[square] == 'x':
            true_board[square] = 'x'
        elif player_board[square] == 'o' or other_player_board[square] == 'o':
            true_board[square] = 'o'
        else:
            true_board[square] = '-'

    return true_board

def opponent_win_exists(board, turn): # expects decoded board
    w_e, sq = win_exists(board, toggle_turn(turn))
    if w_e:
        return w_e, sq
    else:
        return False, -1

def has_perfect_information(board, depth): # expects decoded board
    play_count = 0
    board = copy(board)

    for i in range(9):
        if board[i] == 'x' or board[i] == 'o':
            play_count += 1
        else:
            board[i] = '0'

    if play_count == depth:
        return True, board
    else:
        return False, None

#@title Permutation Code
# permutation code from https://stackoverflow.com/questions/6284396/permutations-with-unique-values

class unique_element:
    def __init__(self,value,occurrences):
        self.value = value
        self.occurrences = occurrences

def perm_unique(elements):
    eset=set(elements)
    listunique = [unique_element(i,elements.count(i)) for i in eset]
    u=len(elements)
    return perm_unique_helper(listunique,[0]*u,u-1)

def perm_unique_helper(listunique,result_list,d):
    if d < 0:
        yield tuple(result_list)
    else:
        for i in listunique:
            if i.occurrences > 0:
                result_list[d]=i.value
                i.occurrences-=1
                for g in  perm_unique_helper(listunique,result_list,d-1):
                    yield g
                i.occurrences+=1

sense_regions = {0: [0, 1, 3, 4],
                 1: [1, 2, 4, 5],
                 2: [3, 4, 6, 7],
                 3: [4, 5, 7, 8]}

def is_empty(board, square):
    return board[square] == '0' or board[square] == '-'

def enumerate_moves(board):
    moves = []
    senses = []

    for i in range(9):
        if board[i] == '0' or board[i] == '-':
            for sense in range(4):
                moves.append(i)
                senses.append(sense)

    return moves, senses

def enumerate_observations(board, move, sense, depth):
    observations = []

    board = board.copy()
    board.make_move(move, 'x')

    sense_region = sense_regions[sense]
    known_opponent_plays = 0
    my_plays = 0
    empty_squares = []

    for i in range(9):
        if board[i] == '0':
            board[i] = '-'
            empty_squares.append(i)
        elif board[i] == '-':
            empty_squares.append(i)
        elif board[i] == 'o':
            known_opponent_plays += 1
        elif board[i] == 'x':
            my_plays += 1

    if my_plays == 5:
        for square in empty_squares:
            board[square] = 'o'
        observations.append(board)
        return observations

    unknown_opponent_plays = depth - known_opponent_plays

    p = ['0' for i in range(len(empty_squares))]
    for i in range(unknown_opponent_plays):
        p[i] = 'o'

    permutations = list(perm_unique(p))

    for permutation in permutations:
        observation = board.copy()

        for i in range(len(empty_squares)):
            if empty_squares[i] in sense_region:
                observation[empty_squares[i]] = permutation[i]

        if observation not in observations:
            observations.append(observation)

    return observations

def count_strategies(board, depth, max_Depth):
    if depth == max_Depth:
        return 0

    moves, senses = enumerate_moves(board)

    strategies = len(moves)
    lower_depth_strategies = 0

    for move, sense in zip(moves, senses):
        observations = enumerate_observations(board, move, sense, depth + 1)

        for observed_board in observations:
            lower_depth_strategies += count_strategies(observed_board, depth + 1, max_Depth)

    if lower_depth_strategies > 0:
        return lower_depth_strategies
    else:
        return strategies

# main
print("Number of Strategies: ", count_strategies(TicTacToeBoard(), 0, 3))